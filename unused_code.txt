# ------------------------------------- CZYTAMY PLIK ZE SPOJNIKAMI I PRZYIMKAMI -------------------------------------- #
try:
    temp = list()
    linkingWords = open("linkingWords.txt").read().split()
except FileNotFoundError as e:
    linkingWords = list()
	
try:
    linkingWords = open("linkingWords.txt").read().split()
except FileNotFoundError as e:
    linkingWords = open("linkingWords.txt", "w+").write("")
    print(e)

for row in range(len(linkingWords)):
    linkingWords[row] = linkingWords[row].casefold()
	
	
for element in range(len(row)):
	if type(row[element]) is not str:
		continue
	for word in linkingWords:
		if word in row[element]:
			row[element] = row[element].replace(" " + word + " ", " ")
# ------------------------------------------------------ KONIEC ------------------------------------------------------ #

# -------------------------------------------------- wordEmbedding --------------------------------------------------- #
jeden wyraz
print(model.wv.most_similar(positive=['girl'], topn=3))  # pokaz najbardziej podobne
print(model.wv.most_similar(negative=['girl'], topn=3))  # pokaz najmniej podobne

j = 1  # iterator - wiersze
for row in dfKey.values:  # for ewery (~R.W.) keyword
    tempPositivities = list()  # tymczasowa lista, przechowuje info o jednym wierszu
    score = model.wv.most_similar(positive=row, topn=3)  # 3 najbardziej podobne wyniki do keyworda
    tempPositivities.append(row[0])  # dodaj keyworda
    for i in range(3):
        tempPositivities.append(score[i][0])  # utnij prawdopodobienstwo, dodaj tylko nazwe

    if j == 1:
       positivities = np.array(tempPositivities)  # pierwszy wpis
    else:
       positivities = np.append(positivities, tempPositivities).reshape((j, len(tempPositivities)))  # konwersja na 2d

    j += 1  # kolejny wiersz

print(positivities)

print(model.wv.vocab)

for word in dfKey.values:
   print(word, " =>", model.wv[word])
# ------------------------------------------------------ KONIEC ------------------------------------------------------ #